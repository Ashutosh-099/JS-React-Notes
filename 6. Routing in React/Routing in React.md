# Routing in React
## SPA (Single page application)
- SPA stands for Single Page Application. It's a type of web application or website that interacts with the user by dynamically rewriting the current web page rather than loading entire new pages from the server.
- In other words, a single HTML page is loaded initially, and then the content is updated dynamically as the user interacts with the application, typically through JavaScript.

**Characteristics of SPA:**
- **Dynamic Updates** - In SPAs, content is loaded and updated without requiring a full page reload. This is achieved using JavaScript and client-side routing.
- **Smooth User Experience** - SPAs can provide a smoother and more responsive user experience because they can update parts of the page without the entire page needing to be refreshed.
- **Faster Initial Load** - While the initial load of an SPA might take longer as it downloads more JavaScript and assets, subsequent interactions with the application can be faster because only data is exchanged with the server and not entire HTML pages.
- **Client-Side Routing** - SPAs often use client-side routing to simulate traditional page navigation while staying on the same HTML page. This is typically achieved using libraries like React Router or Vue Router.
- **API-Centric** - SPAs are often designed to be more API-centric, where the client communicates with a backend API to fetch and send data, usually in JSON format. This allows for decoupling the front end and back end.
- **State Management** - SPAs often use state management libraries (e.g., Redux for React or Vuex for Vue) to manage the application's state and data flow.

Popular JavaScript frameworks and libraries like React, Angular, and Vue are commonly used to build SPAs. They offer tools and patterns to create efficient and maintainable single-page application.

## Client Side routing - Server Side routing
Client-side routing and server-side routing are two different approaches to handling routing and navigation in web applications. They have distinct characteristics and are often used for different purposes. Here's an overview of the key differences between them:

- `Client-Side Routing`: **Handling on the Client** - In client-side routing, routing and navigation are managed on the client side, typically within the web browser. JavaScript frameworks and libraries, such as React Router (for React applications) or Vue Router (for Vue.js applications), are commonly used to implement client-side routing.

**Faster Transitions** - Client-side routing allows for faster page transitions since it doesn't require the server to send a new HTML page for each route change. Instead, it updates the DOM and URL dynamically without full page reloads.

**Single-Page Application (SPA)** - Client-side routing is often associated with single-page applications (SPAs), where the initial HTML page is loaded, and subsequent page changes are made by updating the content using JavaScript.

**SEO Challenges** - SPAs can face challenges with search engine optimization (SEO) because search engine crawlers may not fully index the content that relies heavily on client-side rendering. Special techniques like server-side rendering (SSR) or pre-rendering can be used to address this issue.

**Route Management** - Routing configuration is typically defined in code and managed on the client side, allowing for dynamic and flexible route handling.

- `Server-Side Routing`: **Handling on the Server** - Server-side routing manages routing and navigation on the server. When a user requests a different URL, the server generates and sends a new HTML page for that route.

**Slower Transitions** - Server-side routing tends to be slower in terms of page transitions compared to client-side routing, as it involves full page reloads.

**Traditional Websites** - Server-side routing is commonly used for traditional multi-page websites where each page is a separate HTML document generated by the server.

**SEO-Friendly** - Server-side routing is inherently more SEO-friendly, as each page is a separate HTML document that can be easily crawled and indexed by search engines.

**Route Configuration** - Routing configuration in server-side routing is typically managed on the server, and URLs directly correspond to individual HTML files or routes.


## React Routing: (React router dom)
- React Router enables "client side routing".
- React router is an external package that will helps to add client side routing in our application.

### Installation:
`npm install react-router-dom`

### Router configuration in application:
#### Step 1: Adding a Router
- First thing to do is create a Browser Router and configure our first route. This will enable client side routing for our web app.
- The index.jsx file is the entry point. Open it up and we'll put React Router on the page.
```
import * as React from 'react';
import * as ReactDOM from 'react-dom/client';
import { createBrowserRouter, RouterProvider } from 'react-router-dom';

const router = createBrowserRouter([
  {
    path: "/",
    element: <div>Hello world</div>,    // Replace with the component instead of this
    // element: <App />
  },
]);

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <ReactProvider router={router}/>
  </React.StrictMode>
);
```

#### Handling errors in React routing:
- It's always a good idea to know how your app responds to errors early in the project because we all write far more bugs than features when building a new app! Not only will your users get a good experience when this happens, but it helps you during development as well.
- However, React router also gives its own error page, but we can also give customize error page.
- Let's create our own error page.

`ErrorPage.jsx`
```
import { useRouteError } from 'react-router-dom';

const ErrorPage = () => {
  const error = useRouteError();
  return (
    <div id="error-page">
      <h1>Oops!</h1>
      <p>Sorry, an unexpected error has occurred.</p>
      <p>
        <i>{error.statusText || error.message}</i>
      </p>
    </div>
  );
}

// Do this change in index.jsx
import ErrorPage from "./error-page";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
  },
]);
```


#### Passing dynamic value as parameter in URL
- We can pass value with the routes using `:`.
- E.g. `"/contact/:contact"`
```
const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    errorElement: <ErrorPage />,
  },
  {
    path: "/contact/:conID,
    element: <Contact />,
  }
]);

// In Contact.jsx, do this change for accepting the parameter value

import { useParams } from 'react-router-dom';

const Contact = () => {
  const { conId } = useParams();

  return(
    .....
  );
}
```
- The `useParams` hook returns an object of key/value pairs of the dynamic params from the current URL that were matched by the <Route path>.

#### Nested Routes
- We can also create childrens of main route.
```
const route = createBrowserRouter([
  {
    path: "/",
    element: "<Root />,
    errorElement: <ErrorPage />,
    children: [
      {
        path: "/",
        element: <Body />,
      },
      {
        path: "/contact",
        element: <Contact />,
      },
    ],
  }
]);
```

- But it will not work, because We need to tell the root route where we want it to render its child routes. We do that with `<Outlet>`.
- In Root.jsx
```
import { Outlet } from "react-router-dom";

export default function Root() {
  return (
    <>
      {/* all the other elements */}
      <div id="detail">
        <Outlet />
      </div>
    </>
  );
}
```
- An <Outlet> should be used in parent route elements to render their child route elements.
- This allows nested UI to show up when child routes are rendered. If the parent route matched exactly, it will render a child index route or nothing if there is no index route.

#### <Link>
- A <Link> is an element that lets the user navigate to another page by clicking or tapping on it. In react-router-dom, a <Link> renders an accessible <a> element with a real href that points to the resource it's linking to.
- This means that things like right-clicking a <Link> work as you'd expect. You can use <Link reloadDocument> to skip client side routing and let the browser handle the transition normally (as if it were an <a href>).
- USE <Link> INSTEAD OF <a> tag, because it will not reload the page on URL change, it will update the DOM, which is very fast.
```
<Link to={user.id}>{user.name}</Link>
```

## Another Routers:
- There are different Routers provided by Router-dom, based on requirement we can use them, but the recommended way is createBrowserRouter only.
- Several routers are:
  1. createBrowserRouter (default)
  2. createHashRouter
  3. createMemoryRouter
  4. createStaticRouter etc...

### createHashRouter
- createHashRouter is part of react-router library and provides routing capabilities for SPAs. It's commonly used for buidling client-side navigation within applications.
- Unlike, traditional server-side routing, it uses the fragment identified (hash) in the URL to manage and handle routes on the client side.
- This means that changes in the URL after the #symbol do not trigger a fill page reload, making it suitable for SPAs.
- To use createHashRouter, we typically import it from the react router library and define our routes using Route components, Here's basic example of how you might use it.
```
import { createHashRouter, Route } from 'react-router-dom';

const App = () => {
  return (
    <createHashRouter>
      <Route path="/" component={Home} />
      <Route path="/about" component={About} />
    </createHashRouter>
  )
}
```

### createMemoryRouter
- createMemoryRouter is another routing component provided by React router.
- Unline createHashRouter or BrowserRouter, createMemoryRouter is not associated with browser URL.
- Instead, it allows you to create an in-memory router for testing or other scenarios where you don't want to interact with actual browser's URL.
```
import { createMemoryRouter, Route } from 'react-router-dom';

const App = () => {
  return(
    <createMemoryRouter>
      <Route path="/" component={Home} />
      <Route path="/about" component={About} />
    </createMemoryRouter>
  );
}
```
- In both cases, hash and memory router, we define our application's routes within the router component and specifiy the components to render for each route.
- The choice between the router methods depends on our specific use case, such as whether we're building an SPA that interacts with the browser's URL or a scenaris where we need an in-memory router for testing.

## Protected Routes
Protected Routes are the routes which should be accessed only after user authentication, if user is not authenticated then it will be redirected to Login. Therefore, Protected routes in React Router DOM are used to restrict access to certain parts of your application based on user authentication.

To make the route protected we can use Higher Order Component concept, i.e. create a wrapper class which takes the component and checks if user is authenticated or not, if no then navigate to Login page.
```
// ProtectedRouter.jsx
const ProtectedRouter = () => {
  const isAuthenticated = // Logic of authentication check

  return isAuthenticated ? <Outlet /> : <Navigate to={"/login"} />;
}

// App.jsx
<BrowserRouter>
  <Routes>
    <Route path="/login" element={<Login />} />
    <Route element={<ProtectedRouter/>}>
      <Route path="/home" element={<Home />} />
      <Route path="/about" element={<AboutUs />} />
    </Route>
  </Routes>
</BrowserRouter>
```
- Another Approach is
```
// ProtectedRouter.jsx
const ProtectedRouter = ({element: Element}) => {
  const isAuthenticated = // Logic of checking authentication

  return isAuthenticated ? <Element /> : <Navigate to="/login" />;
}

// App.jsx
const router = createBrowserRouter([
  {
    path: "/login",
    element: <Login />
  },
  {
    path: "/",
    element: <ProtectedRouter element={<Home />} />
  }
]);

<RouterProvider router={router} />
```
